<!DOCTYPE html>
<html>
<head>
    <title>Управление цитатами</title>
    <style> /* Добавим немного стиля для таблицы */
        table, th, td {
            border: 1px solid black;
            border-collapse: collapse;
            padding: 5px;
        }
        th {
            background-color: #f2f2f2;
        }
        button {
            cursor: pointer;
        }
    </style>
</head>
<body>
    <h1>Добавить новую цитату</h1>
    <form id="addQuoteForm">
        <label for="quote">Цитата:</label><br>
        <textarea id="quote" name="quote" rows="3" cols="50"></textarea><br>
        <label for="author">Автор:</label><br>
        <input type="text" id="author" name="author" size="50"><br><br>
        <button type="button" onclick="addQuote()">Добавить цитату</button>
    </form>

    <!-- Форма удаления УДАЛЕНА -->

    <h2>Текущие цитаты</h2>
    <div id="quotesContainer">
        <!-- Содержимое будет загружено динамически JavaScript'ом,
             но оставим начальную структуру для примера и на случай отключенного JS -->
        {% if data %}
        <table>
            <thead>
                <tr>
                    <th>Цитата</th>
                    <th>Автор</th>
                    <th>Дата добавления</th>
                    <th>Действие</th> <!-- Новый заголовок для кнопки -->
                </tr>
            </thead>
            <tbody>
                {% for row in data %}
                <tr>
                    <td>{{ row[0] }}</td> <!-- Индекс 0 для цитаты -->
                    <td>{{ row[1] }}</td>
                    <td>{{ row[2] }}</td>
                    <td>
                        <!-- Кнопка удаления для каждой строки -->
                        <!-- Передаем цитату (row[0]) в JS функцию. |e - важно для экранирования! -->
                        <button type="button" onclick="deleteQuoteByText('{{ row[0] | e }}')">Удалить</button>
                    </td>
                </tr>
                {% endfor %}
            </tbody>
        </table>
        {% else %}
        <p>Нет доступных цитат.</p>
        {% endif %}
    </div>

    <script>
        // Функция addQuote остается без изменений

        async function addQuote() {
            const form = document.getElementById('addQuoteForm');
            const formData = new FormData(form);
            const quote = formData.get('quote');
            const author = formData.get('author');

            if (!quote || !author) {
                 alert('Пожалуйста, введите и цитату, и автора.');
                 return;
            }

            try {
                const response = await fetch('/add_quote', {
                    method: 'POST',
                    body: formData
                });

                if (response.ok) {
                    const data = await response.json();
                    console.log(data.message);
                    fetchAndUpdateQuotes(); // Обновляем список после добавления
                    form.reset(); // Очищаем форму
                } else {
                    const errorData = await response.json();
                    console.error('Ошибка добавления цитаты:', errorData.error);
                    alert('Не удалось добавить цитату: ' + errorData.error);
                }
            } catch (error) {
                console.error('Сетевая ошибка при добавлении:', error);
                alert('Произошла сетевая ошибка при добавлении цитаты.');
            }
        }

        // Старая функция deleteQuote УДАЛЕНА

        // НОВАЯ функция для удаления по кнопке
        async function deleteQuoteByText(quoteText) {
            // Спрашиваем подтверждение у пользователя
            if (!confirm(`Вы уверены, что хотите удалить цитату: "${quoteText}"?`)) {
                return; // Пользователь отменил удаление
            }

            // Создаем FormData, чтобы отправить данные в нужном формате
            const formData = new FormData();
            formData.append('quote', quoteText); // Ключ 'quote', как ожидает бэкенд

            try {
                const response = await fetch('/delete_quote', {
                    method: 'POST', // Метод POST, как в твоем Flask route
                    body: formData
                });

                if (response.ok) {
                    const data = await response.json();
                    console.log(data.message);
                    fetchAndUpdateQuotes(); // Обновляем список цитат после удаления
                } else {
                    const errorData = await response.json();
                    console.error('Ошибка удаления цитаты:', errorData.error);
                    alert('Не удалось удалить цитату: ' + errorData.error);
                }
            } catch (error) {
                console.error('Сетевая ошибка при удалении:', error);
                alert('Произошла сетевая ошибка при удалении цитаты.');
            }
        }


        // Функция fetchAndUpdateQuotes НУЖНО ОБНОВИТЬ, чтобы она добавляла кнопку
        async function fetchAndUpdateQuotes() {
            try {
                const response = await fetch('/get_quotes'); // Используем твой эндпоинт
                if (response.ok) {
                    const data = await response.json();
                    const quotesContainer = document.getElementById('quotesContainer');
                    quotesContainer.innerHTML = ''; // Очищаем контейнер перед обновлением

                    if (data.quotes && data.quotes.length > 0) {
                        const table = document.createElement('table');
                        const thead = document.createElement('thead');
                        const tbody = document.createElement('tbody');

                        // Создаем заголовок таблицы
                        const headerRow = document.createElement('tr');
                        ['Цитата', 'Автор', 'Дата добавления', 'Действие'].forEach(headerText => { // Добавлен 'Действие'
                            const th = document.createElement('th');
                            th.textContent = headerText;
                            headerRow.appendChild(th);
                        });
                        thead.appendChild(headerRow);
                        table.appendChild(thead);

                        // Заполняем тело таблицы
                        data.quotes.forEach(item => { // 'item' содержит {quote: ..., author: ..., dateOfadd: ...}
                            const row = document.createElement('tr');

                            // Ячейка с цитатой
                            const quoteCell = document.createElement('td');
                            quoteCell.textContent = item.quote;
                            row.appendChild(quoteCell);

                            // Ячейка с автором
                            const authorCell = document.createElement('td');
                            authorCell.textContent = item.author;
                            row.appendChild(authorCell);

                            // Ячейка с датой
                            const dateCell = document.createElement('td');
                            dateCell.textContent = item.dateOfadd;
                            row.appendChild(dateCell);

                            // Ячейка с кнопкой удаления
                            const actionCell = document.createElement('td');
                            const deleteButton = document.createElement('button');
                            deleteButton.textContent = 'Удалить';
                            deleteButton.type = 'button';
                            // Важно: Используем стрелочную функцию, чтобы правильно передать item.quote
                            // в обработчик onclick при создании кнопки.
                            deleteButton.onclick = () => deleteQuoteByText(item.quote);
                            actionCell.appendChild(deleteButton);
                            row.appendChild(actionCell);

                            tbody.appendChild(row);
                        });
                        table.appendChild(tbody);
                        quotesContainer.appendChild(table);
                    } else {
                        quotesContainer.innerHTML = '<p>Нет доступных цитат.</p>';
                    }
                } else {
                    console.error('Ошибка при получении цитат:', response.status);
                    quotesContainer.innerHTML = '<p>Не удалось загрузить цитаты.</p>';
                }
            } catch (error) {
                console.error('Сетевая ошибка при получении цитат:', error);
                quotesContainer.innerHTML = '<p>Произошла сетевая ошибка при загрузке цитат.</p>';
            }
        }

        // Загружаем цитаты при первой загрузке страницы
        window.onload = fetchAndUpdateQuotes;
    </script>
</body>
</html>